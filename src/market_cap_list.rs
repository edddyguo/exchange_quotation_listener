use crate::constant::{BNB_API_KEY, RECV_WINDOW};
use crate::utils::hmac_sha256_sign;
use crate::{get_unix_timestamp_ms, try_get};
use reqwest::header::{HeaderMap, HeaderName, HeaderValue, CONTENT_TYPE};
///获取u本位账号基本信息（可用余额）
///
///
/// curl -H "X-CMC_PRO_API_KEY: 92e6f509-4ef9-4ee1-8e54-4e3a732df2e9" -H "Accept: application/json"  -d "limit=150" -G https://pro-api.coinmarketcap.com/v1/cryptocurrency/listings/latest|jq|grep symbol//use serde_derive::Deserialize;
//use serde_derive::Serialize;
use serde::{Deserialize, Serialize};
use std::ops::Deref;

use std::collections::HashMap;

lazy_static! {
    pub static ref MY_MAP: HashMap<&'static str, Vec<&'static str>> = {
        let mut map = HashMap::new();
        map.insert("2022-01", vec![
            "1INCH",
            "BTC",
"ETH",
"BNB",
"USDT",
"SOL",
"ADA",
"XRP",
"USDC",
"LUNA",
"DOT",
"AVAX",
"DOGE",
"SHIB",
"MATIC",
"CRO",
"BUSD",
"WBTC",
"UNI",
"LTC",
"LINK",
"ALGO",
"UST",
"NEAR",
"DAI",
"BCH",
"TRX",
"ATOM",
"XLM",
"MANA",
"AXS",
"SAND",
"VET",
"FTM",
"FTT",
"HBAR",
"THETA",
"BTCB",
"FIL",
"EGLD",
"ICP",
"ETC",
"XTZ",
"HNT",
"XMR",
"MIOTA",
"AAVE",
"GALA",
"KLAY",
"GRT",
"LEO",
"EOS",
"CAKE",
"LRC",
"ONE",
"STX",
"FLOW",
"BTT",
"KSM",
"ENJ",
"MKR",
"KDA",
"CRV",
"BSV",
"QNT",
"XEC",
"ZEC",
"AMP",
"NEO",
"AR",
"BAT",
"RUNE",
"CHZ",
"CELO",
"OKB",
"KCS",
"WAVES",
"DASH",
"HT",
"HOT",
"COMP",
"NEXO",
"IOTX",
"TUSD",
"ROSE",
"MINA",
"XEM",
"TFUEL",
"YFI",
"DCR",
"ICX",
"RVN",
"XDC",
"SUSHI",
"QTUM",
"AUDIO",
"OMG",
"USDP",
"WAXP",
"BORA",
"SCRT",
"ZIL",
"ANKR",
"LPT",
"CEL",
"VGX",
"ELON",
"IMX",
"NFT",
"REV",
"RENBTC",
"ZEN",
"BNT",
"SC",
"TEL",
"BTG",
"ZRX",
"STORJ",
"VLX",
"SNX",
"GNO",
"PERP",
"HIVE",
"CKB",
"IOST",
"UMA",
"ONT",
"REN",
"SKL",
"CHSB",
"DYDX",
"RAY",
"KAVA",
"OCEAN",
"DGB",
"NU",
"WOO",
"FLUX",
"SRM",
"USDN",
"CELR",
"GT",
"XNO",
"CEEK",
"SYS",
"GLM",
"POLY",
"WIN",
"MOVR",
"XYO"]);
        map.insert("2022-02", vec![
                        "1INCH",
            "BTC",
"ETH",
"USDT",
"BNB",
"USDC",
"ADA",
"SOL",
"XRP",
"LUNA",
"DOGE",
"DOT",
"AVAX",
"BUSD",
"MATIC",
"SHIB",
"UST",
"CRO",
"WBTC",
"DAI",
"LINK",
"ATOM",
"LTC",
"UNI",
"NEAR",
"ALGO",
"TRX",
"FTT",
"BCH",
"FTM",
"XLM",
"MANA",
"BTCB",
"HBAR",
"ICP",
"SAND",
"LEO",
"VET",
"ETC",
"AXS",
"HNT",
"KLAY",
"FIL",
"EGLD",
"THETA",
"XTZ",
"XMR",
"EOS",
"MIOTA",
"FLOW",
"ONE",
"AAVE",
"BTT",
"MKR",
"CAKE",
"STX",
"GRT",
"BSV",
"ENJ",
"TUSD",
"CRV",
"XEC",
"HT",
"KCS",
"NEO",
"KSM",
"LRC",
"RUNE",
"GALA",
"CVX",
"ZEC",
"OKB",
"AMP",
"BAT",
"AR",
"CELO",
"QNT",
"ROSE",
"CHZ",
"NEXO",
"WAVES",
"KDA",
"XYM",
"DASH",
"TFUEL",
"USDP",
"XEM",
"BORA",
"YFI",
"DCR",
"MINA",
"SCRT",
"HOT",
"COMP",
"XDC",
"IOTX",
"RVN",
"OMG",
"RENBTC",
"ANKR",
"WAXP",
"RNDR",
"CEL",
"SPELL",
"SNX",
"BNT",
"QTUM",
"CHSB",
"LPT",
"NFT",
"VLX",
"ZIL",
"RLY",
"GT",
"ICX",
"SUSHI",
"GNO",
"BTG",
"USDN",
"WOO",
"SC",
"VGX",
"IMX",
"ZEN",
"ELON",
"PERP",
"KAVA",
"SYS",
"ZRX",
"AUDIO",
"IOST",
"TEL",
"REV",
"GLMR",
"STORJ",
"CKB",
"FEI",
"ONT",
"PEOPLE",
"UMA",
"ENS",
"DYDX",
"SOS",
"ILV",
"HIVE",
"SKL",
"OCEAN",
"PAXG",
"FXS",
"FLUX"
        ]);
        map.insert("2022-03", vec![
                        "1INCH",
            "BTC",
"ETH",
"USDT",
"BNB",
"USDC",
"XRP",
"ADA",
"LUNA",
"SOL",
"AVAX",
"BUSD",
"DOT",
"DOGE",
"UST",
"SHIB",
"MATIC",
"CRO",
"WBTC",
"DAI",
"ATOM",
"LTC",
"UNI",
"LINK",
"TRX",
"BCH",
"FTT",
"LEO",
"NEAR",
"ALGO",
"MANA",
"XLM",
"HBAR",
"FTM",
"BTCB",
"ETC",
"ICP",
"FIL",
"SAND",
"KLAY",
"EGLD",
"AXS",
"VET",
"THETA",
"XTZ",
"XMR",
"HNT",
"EOS",
"MIOTA",
"FLOW",
"AAVE",
"MKR",
"BTT",
"CAKE",
"ONE",
"GALA",
"GRT",
"BSV",
"KCS",
"TUSD",
"STX",
"HT",
"ZEC",
"NEO",
"XEC",
"QNT",
"WAVES",
"ENJ",
"RUNE",
"AMP",
"NEXO",
"KDA",
"OKB",
"CHZ",
"BAT",
"KSM",
"CRV",
"LRC",
"AR",
"CELO",
"USDP",
"ANC",
"DASH",
"CVX",
"XEM",
"TFUEL",
"SCRT",
"BORA",
"XYM",
"MINA",
"DCR",
"ROSE",
"YFI",
"HOT",
"COMP",
"CEL",
"IOTX",
"XDC",
"GNO",
"RVN",
"QTUM",
"BNT",
"WAXP",
"RENBTC",
"RLY",
"OMG",
"PAXG",
"ANKR",
"BTG",
"VLX",
"RNDR",
"LPT",
"KEEP",
"GT",
"ZIL",
"CHSB",
"USDN",
"ICX",
"GLM",
"KAVA",
"NFT",
"ONT",
"VGX",
"AUDIO",
"ZRX",
"SC",
"GLMR",
"SNX",
"IOST",
"FEI",
"ELON",
"REV",
"SUSHI",
"WOO",
"ZEN",
"NU",
"SKL",
"STORJ",
"SYS",
"HIVE",
"POLY",
"ILV",
"SPELL",
"KNC",
"FXS",
"DYDX",
"PERP",
"UOS",
"IMX",
"CKB"
        ]);
        map.insert("2022-04", vec![
                        "1INCH",
            "BTC",
"ETH",
"USDT",
"BNB",
"USDC",
"XRP",
"ADA",
"SOL",
"LUNA",
"AVAX",
"DOT",
"DOGE",
"BUSD",
"UST",
"SHIB",
"MATIC",
"WBTC",
"CRO",
"DAI",
"LTC",
"NEAR",
"ATOM",
"LINK",
"UNI",
"BCH",
"FTT",
"TRX",
"ETC",
"ALGO",
"LEO",
"XLM",
"MANA",
"BTCB",
"VET",
"HBAR",
"ICP",
"FIL",
"EGLD",
"AXS",
"APE",
"SAND",
"XMR",
"FTM",
"THETA",
"WAVES",
"RUNE",
"XTZ",
"KLAY",
"ZEC",
"HNT",
"EOS",
"FLOW",
"MIOTA",
"AAVE",
"CAKE",
"GRT",
"MKR",
"BTT",
"ONE",
"STX",
"XEC",
"NEO",
"BSV",
"GALA",
"QNT",
"CVX",
"CHZ",
"ENJ",
"KCS",
"KSM",
"LRC",
"HT",
"CELO",
"DASH",
"OKB",
"TUSD",
"NEXO",
"BAT",
"ZIL",
"AR",
"CRV",
"HOT",
"KDA",
"MINA",
"AMP",
"XEM",
"TFUEL",
"ROSE",
"USDP",
"DCR",
"IOTX",
"XYM",
"QTUM",
"COMP",
"SCRT",
"YFI",
"SXP",
"CEL",
"USDN",
"BORA",
"BTG",
"OMG",
"XDC",
"RVN",
"GNO",
"ICX",
"ANKR",
"BNT",
"RENBTC",
"WAXP",
"KAVA",
"ANC",
"AUDIO",
"RNDR",
"PAXG",
"SNX",
"IOST",
"SC",
"LPT",
"ZRX",
"WOO",
"ZEN",
"VGX",
"GLMR",
"DGB",
"KNC",
"VLX",
"RLY",
"ONT",
"IMX",
"SKL",
"GLM",
"TEL",
"UMA",
"GT",
"STORJ",
"SUSHI",
"NFT",
"ELON",
"XDB",
"REV",
"TWT",
"GMT",
"HIVE",
"JST",
"CHSB",
"POLY",
"SYS",
"FEI"
        ]);
        map.insert("2022-05", vec![

        ]);
        map.insert("2022-06", vec![

        ]);
        map.insert("2022-07", vec![

        ]);
        map.insert("2022-08", vec![

        ]);
        map.insert("2022-09", vec![

        ]);
        map.insert("2022-10", vec![

        ]);
        map.insert("2022-11", vec![

        ]);
        map.insert("2022-12", vec![

        ]);
        map.insert("2023-01", vec![

        ]);
        map.insert("2023-02", vec![

        ]);
        map.insert("2023-03", vec![

        ]);
        map.insert("2023-04", vec![

        ]);

        map
    };
}

//use serde_derive::Deserialize;
//use serde_derive::Serialize;
//use serde_json::Value;
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Root {
    pub status: Status,
    pub data: Vec<Daum>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Status {
    pub timestamp: String,
    #[serde(rename = "error_code")]
    pub error_code: i64,
    #[serde(rename = "error_message")]
    pub error_message: Option<String>,
    pub elapsed: i64,
    #[serde(rename = "credit_count")]
    pub credit_count: i64,
    pub notice: Option<String>,
    #[serde(rename = "total_count")]
    pub total_count: i64,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Daum {
    pub id: i64,
    pub name: String,
    pub symbol: String,
    pub slug: String,
    #[serde(rename = "num_market_pairs")]
    pub num_market_pairs: i64,
    #[serde(rename = "date_added")]
    pub date_added: String,
    pub tags: Vec<String>,
    #[serde(rename = "max_supply")]
    pub max_supply: Option<i64>,
    #[serde(rename = "circulating_supply")]
    pub circulating_supply: f64,
    #[serde(rename = "total_supply")]
    pub total_supply: f64,
    #[serde(rename = "infinite_supply")]
    pub infinite_supply: bool,
    pub platform: Option<Platform>,
    #[serde(rename = "cmc_rank")]
    pub cmc_rank: i64,
    #[serde(rename = "self_reported_circulating_supply")]
    pub self_reported_circulating_supply: Option<f64>,
    #[serde(rename = "self_reported_market_cap")]
    pub self_reported_market_cap: Option<f64>,
    #[serde(rename = "tvl_ratio")]
    pub tvl_ratio: Option<f64>,
    #[serde(rename = "last_updated")]
    pub last_updated: String,
    pub quote: Quote,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Platform {
    pub id: i64,
    pub name: String,
    pub symbol: String,
    pub slug: String,
    #[serde(rename = "token_address")]
    pub token_address: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Quote {
    #[serde(rename = "USD")]
    pub usd: Usd,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Usd {
    pub price: f64,
    #[serde(rename = "volume_24h")]
    pub volume_24h: f64,
    #[serde(rename = "volume_change_24h")]
    pub volume_change_24h: f64,
    #[serde(rename = "percent_change_1h")]
    pub percent_change_1h: f64,
    #[serde(rename = "percent_change_24h")]
    pub percent_change_24h: f64,
    #[serde(rename = "percent_change_7d")]
    pub percent_change_7d: f64,
    #[serde(rename = "percent_change_30d")]
    pub percent_change_30d: f64,
    #[serde(rename = "percent_change_60d")]
    pub percent_change_60d: f64,
    #[serde(rename = "percent_change_90d")]
    pub percent_change_90d: f64,
    #[serde(rename = "market_cap")]
    pub market_cap: f64,
    #[serde(rename = "market_cap_dominance")]
    pub market_cap_dominance: f64,
    #[serde(rename = "fully_diluted_market_cap")]
    pub fully_diluted_market_cap: f64,
    pub tvl: Option<f64>,
    #[serde(rename = "last_updated")]
    pub last_updated: String,
}


pub async fn market_cap_list(limit: u32) -> Vec<String> {
    let mut headers = HeaderMap::new();
    headers.insert(
        HeaderName::from_static("x-cmc_pro_api_key"),
        HeaderValue::from_static("92e6f509-4ef9-4ee1-8e54-4e3a732df2e9"),
    );

    let request_parameter = format!("limit={}", limit);
    let url = format!(
        "https://pro-api.coinmarketcap.com/v1/cryptocurrency/listings/latest?{}",
        request_parameter
    );
    let client = reqwest::Client::new();
    let res = client
        .get(url)
        .headers(headers)
        .send()
        .await
        .unwrap()
        .json::<Root>()
        .await
        .unwrap();
    res.data.iter().map(|x| format!("{}USDT", x.symbol)).collect()
}
pub fn get_market_cap_list_by_month(month: &str) -> Vec<String> {
    MY_MAP.get(month)
        .unwrap()
        .iter()
        .map(|&symbol| symbol.to_string() + "USDT")
        .collect()
}
